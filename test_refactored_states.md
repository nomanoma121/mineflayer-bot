# リファクタリング後の状態管理システム - テストガイド

## 変更内容の概要

### 1. AttackingState の改良
- **親状態の記憶**: 戦闘完了後に元の状態に戻る機能を追加
- **コンストラクタ**: `parentState` パラメータを追加
- **戦闘完了時**: `parentState` があれば戻り、なければ `IdleState` に遷移

### 2. ServantState の責任分離
- **削除された機能**: 戦闘ロジック（攻撃、位置追跡、戦闘判定）
- **残った機能**: マスター追従、脅威検出、AttackingState への委譲
- **新機能**: 間隔ベースの脅威チェック、適切なイベント管理

### 3. KillCommand の更新
- **状態保存**: 現在の状態を保存して戦闘後に復帰
- **改良されたコールバック**: 戦闘完了メッセージの処理

## テストケース

### Case 1: 基本的な脅威検出
```
1. Bot を ServantState に設定
2. 敵対モブを近くに配置
3. 期待される動作:
   - ServantState が脅威を検出
   - AttackingState に委譲
   - 戦闘完了後に ServantState に戻る
```

### Case 2: マスター/ボット攻撃時の反撃
```
1. Bot を ServantState に設定
2. マスターまたはボットを攻撃
3. 期待される動作:
   - entityHurt イベントが発動
   - AttackingState に委譲
   - 戦闘完了後に ServantState に戻る
```

### Case 3: Kill コマンドの動作
```
1. Bot を任意の状態に設定
2. Kill コマンドを実行
3. 期待される動作:
   - 現在の状態を保存
   - AttackingState に遷移
   - 戦闘完了後に元の状態に戻る
```

## 利点

1. **責任分離**: 各状態が明確な役割を持つ
2. **再利用性**: AttackingState は任意の状態から呼び出し可能
3. **安定性**: 状態遷移の競合が解決
4. **保守性**: 戦闘ロジックが一箇所に集約

## 潜在的な問題と対策

1. **状態遷移の循環**: 親状態が自分自身を参照する場合
   - 対策: 状態遷移時の検証ロジック追加

2. **イベントリスナーの重複**: 複数の状態でイベントを監視
   - 対策: 各状態のenter/exitで適切な登録/解除

3. **戦闘中の状態変更**: 外部から強制的に状態を変更
   - 対策: 状態変更時のリソース解放
