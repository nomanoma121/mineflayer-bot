# ãƒ†ã‚¹ãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ - åŒ…æ‹¬çš„å“è³ªä¿è¨¼æˆ¦ç•¥

## ğŸ“– ãƒ†ã‚¹ãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ã€**312ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã«ã‚ˆã‚‹åŒ…æ‹¬çš„å“è³ªä¿è¨¼ã‚·ã‚¹ãƒ†ãƒ **ã‚’æ§‹ç¯‰ã—ã¦ã„ã¾ã™ã€‚å˜ä½“ãƒ†ã‚¹ãƒˆã‹ã‚‰çµ±åˆãƒ†ã‚¹ãƒˆã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã¾ã§ã€å¤šå±¤çš„ãªãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã«ã‚ˆã‚Šã€é«˜å“è³ªãªã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢é–‹ç™ºã‚’å®Ÿç¾ã—ã¦ã„ã¾ã™ã€‚

## ğŸ¯ ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### ãƒ†ã‚¹ãƒˆéšå±¤æ§‹é€ 

```
ãƒ†ã‚¹ãƒˆéšå±¤                   ãƒ†ã‚¹ãƒˆæ•°    ã‚«ãƒãƒ¬ãƒƒã‚¸å¯¾è±¡               è²¬å‹™
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Unit Tests              ~200     å€‹åˆ¥ã‚¯ãƒ©ã‚¹ãƒ»ãƒ¡ã‚½ãƒƒãƒ‰        æ©Ÿèƒ½ã®æ­£ç¢ºæ€§
Integration Tests       ~50      ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆé–“é€£æº        ç›¸äº’ä½œç”¨ã®æ¤œè¨¼
System Tests           ~30      ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰å‹•ä½œ        å…¨ä½“å‹•ä½œã®ç¢ºèª
Performance Tests      ~32      å®Ÿè¡Œæ™‚é–“ãƒ»ãƒ¡ãƒ¢ãƒªåŠ¹ç‡        æ€§èƒ½è¦ä»¶ã®æ¤œè¨¼
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
åˆè¨ˆ                   312      å…¨ã‚·ã‚¹ãƒ†ãƒ                   å“è³ªä¿è¨¼
```

### ãƒ†ã‚¹ãƒˆåˆ†é¡ãƒãƒˆãƒªã‚¯ã‚¹

| ãƒ†ã‚¹ãƒˆç¨®é¡ | å®Ÿè¡Œé »åº¦ | å®Ÿè¡Œã‚¿ã‚¤ãƒŸãƒ³ã‚° | ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯æ™‚é–“ | ç›®çš„ |
|-----------|---------|---------------|-----------------|------|
| **Unit Tests** | æ¯ã‚³ãƒŸãƒƒãƒˆ | é–‹ç™ºä¸­ | ç§’å˜ä½ | ãƒã‚°ã®æ—©æœŸç™ºè¦‹ |
| **Integration Tests** | æ¯ãƒ—ãƒƒã‚·ãƒ¥ | CI/CD | åˆ†å˜ä½ | é€£æºå•é¡Œã®æ¤œå‡º |
| **System Tests** | æ¯ãƒªãƒªãƒ¼ã‚¹ | ãƒªãƒªãƒ¼ã‚¹å‰ | æ™‚é–“å˜ä½ | å…¨ä½“å‹•ä½œç¢ºèª |
| **Performance Tests** | é€±æ¬¡ | å®šæœŸå®Ÿè¡Œ | æ™‚é–“å˜ä½ | æ€§èƒ½åŠ£åŒ–ã®ç›£è¦– |

## ğŸ§ª ãƒ¢ãƒƒã‚¯æˆ¦ç•¥

### MinecraftBotMockï¼ˆä¸­å¤®ãƒ¢ãƒƒã‚¯ï¼‰

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã§ä½¿ç”¨ã•ã‚Œã‚‹åŒ…æ‹¬çš„ãªmineflayerãƒœãƒƒãƒˆãƒ¢ãƒƒã‚¯ï¼š

```typescript
// src/__mocks__/MinecraftBotMock.ts
export const createMockBot = (): any => {
  const mockBot = {
    // åŸºæœ¬ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
    username: 'TestBot',
    health: 20,
    food: 20,
    foodSaturation: 5,
    
    // ä½ç½®æƒ…å ±
    entity: {
      position: { x: 0, y: 64, z: 0 },
      velocity: { x: 0, y: 0, z: 0 },
      yaw: 0,
      pitch: 0,
      onGround: true
    },
    
    // æ™‚é–“ã‚·ã‚¹ãƒ†ãƒ 
    time: {
      timeOfDay: 6000,
      day: 1,
      doDaylightCycle: true,
      bigTime: BigInt(6000),
      time: 6000,
      age: 1000,
      isDay: true,
      moonPhase: 0,
      bigAge: BigInt(1000)
    },
    
    // çµŒé¨“å€¤ã‚·ã‚¹ãƒ†ãƒ 
    experience: {
      level: 30,
      points: 825,
      total: 1395 // ãƒ¬ãƒ™ãƒ«30ã®ç·çµŒé¨“å€¤
    },
    
    // ç’°å¢ƒçŠ¶æ…‹
    isRaining: false,
    thunderState: 0,
    
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†
    players: new Map(),
    
    // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ç®¡ç†
    entities: {},
    
    // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‚·ã‚¹ãƒ†ãƒ 
    inventory: {
      items: jest.fn(() => []),
      count: jest.fn(() => 0),
      findItem: jest.fn(() => null),
      findItems: jest.fn(() => []),
      slots: Array(45).fill(null)
    },
    
    // è£…å‚™ã‚·ã‚¹ãƒ†ãƒ 
    equipment: Array(6).fill(null),
    
    // ãƒãƒ£ãƒƒãƒˆæ©Ÿèƒ½
    chat: jest.fn(),
    
    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½
    attack: jest.fn().mockResolvedValue(undefined),
    dig: jest.fn().mockResolvedValue(undefined),
    placeBlock: jest.fn().mockResolvedValue(undefined),
    equip: jest.fn().mockResolvedValue(undefined),
    consume: jest.fn().mockResolvedValue(undefined),
    toss: jest.fn().mockResolvedValue(undefined),
    
    // ãƒ¯ãƒ¼ãƒ«ãƒ‰æƒ…å ±
    world: {
      raycast: jest.fn(() => null)
    },
    
    // pathfinderæ©Ÿèƒ½ï¼ˆmineflayer-pathfinderï¼‰
    pathfinder: {
      setMovements: jest.fn(),
      setGoal: jest.fn(),
      goto: jest.fn().mockResolvedValue(undefined),
      stop: jest.fn()
    },
    
    // ãƒ–ãƒ­ãƒƒã‚¯æƒ…å ±
    blockAt: jest.fn().mockReturnValue({
      name: 'air',
      type: 0,
      position: { x: 0, y: 64, z: 0 },
      light: 15
    }),
    
    // ã‚¤ãƒ™ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ 
    on: jest.fn(),
    off: jest.fn(),
    emit: jest.fn(),
    once: jest.fn(),
    
    // æ¥ç¶šçŠ¶æ…‹
    _client: {
      state: 'play'
    }
  };
  
  return mockBot;
};

/**
 * ç‰¹å®šã®çŠ¶æ³ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ãƒ¢ãƒƒã‚¯
 */
export const createLowHealthBot = (): any => {
  const bot = createMockBot();
  bot.health = 3;
  bot.food = 2;
  return bot;
};

export const createRichInventoryBot = (): any => {
  const bot = createMockBot();
  bot.inventory.items.mockReturnValue([
    { name: 'diamond_sword', count: 1, durabilityUsed: 0, maxDurability: 1561 },
    { name: 'bread', count: 64 },
    { name: 'iron_pickaxe', count: 1, durabilityUsed: 50, maxDurability: 250 }
  ]);
  return bot;
};

export const createNightTimeBot = (): any => {
  const bot = createMockBot();
  bot.time.timeOfDay = 18000; // å¤œä¸­
  bot.time.isDay = false;
  return bot;
};
```

### éšå±¤åˆ¥ãƒ¢ãƒƒã‚¯æˆ¦ç•¥

#### 1. Unit Test ãƒ¬ãƒ™ãƒ«

```typescript
// æœ€å°é™ã®ãƒ¢ãƒƒã‚¯ï¼šãƒ†ã‚¹ãƒˆå¯¾è±¡ã®ã‚¯ãƒ©ã‚¹ã®ã¿
describe('VitalsAbility', () => {
  let mockBot: any;
  let vitalsAbility: VitalsAbility;

  beforeEach(() => {
    mockBot = createMockBot();
    vitalsAbility = new VitalsAbility(mockBot);
  });

  test('should detect low health', () => {
    mockBot.health = 3;
    expect(vitalsAbility.isHealthLow()).toBe(true);
  });

  test('should detect normal health', () => {
    mockBot.health = 15;
    expect(vitalsAbility.isHealthLow()).toBe(false);
  });
});
```

#### 2. Integration Test ãƒ¬ãƒ™ãƒ«

```typescript
// è¤‡æ•°ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ãƒ¢ãƒƒã‚¯ï¼šä¾å­˜é–¢ä¿‚ã‚’å«ã‚€
describe('Bot Integration', () => {
  let mockBot: any;
  let bot: Bot;
  let commandHandler: CommandHandler;

  beforeEach(() => {
    mockBot = createMockBot();
    bot = new Bot(mockBot);
    commandHandler = new CommandHandler(bot);
  });

  test('should handle go command with state change', async () => {
    commandHandler.registerCommand('go', new GoCommand());
    
    await commandHandler.handleMessage('player', '@bot go 100 64 200');
    
    expect(bot.getCurrentState().getName()).toBe('Moving');
    expect(mockBot.pathfinder.goto).toHaveBeenCalled();
  });
});
```

#### 3. System Test ãƒ¬ãƒ™ãƒ«

```typescript
// å…¨ã‚·ã‚¹ãƒ†ãƒ ãƒ¢ãƒƒã‚¯ï¼šå®Ÿéš›ã®ä½¿ç”¨ã‚·ãƒŠãƒªã‚ª
describe('BotScript System Tests', () => {
  let mockBot: any;
  let bot: Bot;
  let interpreter: Interpreter;

  beforeEach(() => {
    mockBot = createMockBot();
    bot = new Bot(mockBot);
    interpreter = new Interpreter(bot, new ExecutionContext());
  });

  test('complete farming scenario', async () => {
    const script = `
      DEF $crops_harvested = 0
      REPEAT 10
        DIG "wheat"
        SET $crops_harvested = $crops_harvested + 1
        SAY "Harvested: " + $crops_harvested
        WAIT 0.01
      ENDREPEAT
      SAY "Farming complete!"
    `;

    const result = await executeScript(interpreter, script);
    
    expect(result.type).toBe(ExecutionResultType.SUCCESS);
    expect(mockBot.chat).toHaveBeenCalledWith('Farming complete!');
    expect(mockBot.dig).toHaveBeenCalledTimes(10);
  });
});
```

## ğŸ—ï¸ ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

### ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œãƒ˜ãƒ«ãƒ‘ãƒ¼

```typescript
// src/botscript/__tests__/utils/ScriptExecutor.ts
export async function executeScript(
  interpreter: Interpreter, 
  sourceCode: string,
  timeout = 5000
): Promise<ExecutionResult> {
  const lexer = new Lexer(sourceCode);
  const tokens = lexer.tokenize();
  const parser = new Parser(tokens);
  const ast = parser.parse();
  
  return await interpreter.executeWithTimeout(ast, timeout);
}

export function createTestAST(statements: StatementNode[]): ProgramNode {
  return {
    type: 'Program',
    statements
  };
}

export function createSayStatement(message: string): SayCommandNode {
  return {
    type: 'SayCommand',
    message: {
      type: 'StringLiteral',
      value: message
    }
  };
}

export function createVariableDeclaration(name: string, value: any): VariableDeclarationNode {
  return {
    type: 'VariableDeclaration',
    name,
    initializer: {
      type: typeof value === 'number' ? 'NumberLiteral' : 'StringLiteral',
      value
    }
  };
}
```

### ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãƒ˜ãƒ«ãƒ‘ãƒ¼

```typescript
// src/__tests__/utils/Assertions.ts
export class BotAssertions {
  constructor(private mockBot: any) {}

  expectSaid(message: string): void {
    expect(this.mockBot.chat).toHaveBeenCalledWith(message);
  }

  expectSaidContaining(substring: string): void {
    const calls = this.mockBot.chat.mock.calls;
    const found = calls.some((call: any) => call[0].includes(substring));
    expect(found).toBe(true);
  }

  expectMovedTo(x: number, y: number, z: number): void {
    expect(this.mockBot.pathfinder.goto).toHaveBeenCalledWith(
      expect.objectContaining({
        x: expect.closeTo(x, 1),
        y: expect.closeTo(y, 1),
        z: expect.closeTo(z, 1)
      })
    );
  }

  expectEquipped(item: string, slot: string): void {
    expect(this.mockBot.equip).toHaveBeenCalledWith(
      expect.objectContaining({ name: item }),
      slot
    );
  }

  expectAttacked(target?: string): void {
    if (target) {
      expect(this.mockBot.attack).toHaveBeenCalledWith(
        expect.objectContaining({ name: target })
      );
    } else {
      expect(this.mockBot.attack).toHaveBeenCalled();
    }
  }
}

// ä½¿ç”¨ä¾‹
test('complex bot interaction', async () => {
  const mockBot = createMockBot();
  const assertions = new BotAssertions(mockBot);
  
  await executeComplexScenario(mockBot);
  
  assertions.expectSaid('Hello World');
  assertions.expectMovedTo(100, 64, 200);
  assertions.expectEquipped('diamond_sword', 'hand');
});
```

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

### å®Ÿè¡Œæ™‚é–“æ¸¬å®š

```typescript
// src/__tests__/performance/ExecutionTime.test.ts
describe('BotScript Performance Tests', () => {
  let interpreter: Interpreter;
  let mockBot: any;

  beforeEach(() => {
    mockBot = createMockBot();
    interpreter = new Interpreter(mockBot, new ExecutionContext());
  });

  test('simple script execution should be fast', async () => {
    const script = 'SAY "Hello World"';
    
    const startTime = performance.now();
    const result = await executeScript(interpreter, script);
    const executionTime = performance.now() - startTime;
    
    expect(result.type).toBe(ExecutionResultType.SUCCESS);
    expect(executionTime).toBeLessThan(50); // 50msä»¥å†…
  });

  test('complex script should complete within reasonable time', async () => {
    const script = `
      REPEAT 100
        DEF $temp = $loop_index * 2
        IF $temp > 50 THEN
          SAY "Large number: " + $temp
        ENDIF
      ENDREPEAT
    `;
    
    const startTime = performance.now();
    const result = await executeScript(interpreter, script);
    const executionTime = performance.now() - startTime;
    
    expect(result.type).toBe(ExecutionResultType.SUCCESS);
    expect(executionTime).toBeLessThan(200); // 200msä»¥å†…
  });

  test('lexer performance with large input', () => {
    const largeScript = 'SAY "test"\n'.repeat(1000);
    
    const startTime = performance.now();
    const lexer = new Lexer(largeScript);
    const tokens = lexer.tokenize();
    const lexingTime = performance.now() - startTime;
    
    expect(tokens.length).toBeGreaterThan(2000);
    expect(lexingTime).toBeLessThan(100); // 100msä»¥å†…
  });
});
```

### ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒ†ã‚¹ãƒˆ

```typescript
// src/__tests__/performance/Memory.test.ts
describe('Memory Usage Tests', () => {
  test('execution context should not leak memory', async () => {
    const measureMemory = () => {
      if (global.gc) {
        global.gc();
      }
      return process.memoryUsage().heapUsed;
    };

    const initialMemory = measureMemory();
    
    // å¤§é‡ã®å¤‰æ•°ã‚’ä½œæˆ
    for (let i = 0; i < 1000; i++) {
      const context = new ExecutionContext();
      for (let j = 0; j < 100; j++) {
        context.setVariable(`$var${j}`, `value${j}`);
      }
      context.cleanup();
    }
    
    const finalMemory = measureMemory();
    const memoryIncrease = finalMemory - initialMemory;
    
    // ãƒ¡ãƒ¢ãƒªå¢—åŠ ãŒè¨±å®¹ç¯„å›²å†…ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
    expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024); // 50MBæœªæº€
  });

  test('state instances should be reused (singleton)', () => {
    const instance1 = IdleState.getInstance();
    const instance2 = IdleState.getInstance();
    const instance3 = IdleState.getInstance();
    
    expect(instance1).toBe(instance2);
    expect(instance2).toBe(instance3);
  });
});
```

## ğŸ”§ ãƒ†ã‚¹ãƒˆè¨­å®šã¨CI/CD

### Jestè¨­å®š

```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  
  // ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¿ãƒ¼ãƒ³
  testMatch: [
    '**/__tests__/**/*.test.ts',
    '**/*.test.ts'
  ],
  
  // ã‚«ãƒãƒ¬ãƒƒã‚¸è¨­å®š
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  
  // ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«
  setupFilesAfterEnv: ['<rootDir>/src/__tests__/setup.ts'],
  
  // ãƒ¢ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1'
  },
  
  // ãƒ†ã‚¹ãƒˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
  testTimeout: 10000,
  
  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆç”¨ã®è¨­å®š
  globals: {
    'ts-jest': {
      tsconfig: 'tsconfig.test.json'
    }
  }
};
```

### ãƒ†ã‚¹ãƒˆã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

```typescript
// src/__tests__/setup.ts
import 'jest-extended';

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ¢ãƒƒã‚¯ã®è¨­å®š
jest.mock('mineflayer', () => ({
  createBot: jest.fn(() => createMockBot())
}));

// ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒãƒãƒ£ãƒ¼ã®å®šç¾©
expect.extend({
  toBeWithinRange(received: number, floor: number, ceiling: number) {
    const pass = received >= floor && received <= ceiling;
    if (pass) {
      return {
        message: () => `expected ${received} not to be within range ${floor} - ${ceiling}`,
        pass: true
      };
    } else {
      return {
        message: () => `expected ${received} to be within range ${floor} - ${ceiling}`,
        pass: false
      };
    }
  },

  toHaveExecutedSuccessfully(received: ExecutionResult) {
    const pass = received.type === ExecutionResultType.SUCCESS;
    return {
      message: () => pass 
        ? `expected execution not to succeed`
        : `expected execution to succeed, but got: ${received.message}`,
      pass
    };
  }
});

// ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
afterEach(() => {
  jest.clearAllMocks();
});

// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼
global.performance = global.performance || {
  now: () => Date.now()
};
```

### GitHub Actions CI/CD

```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run linting
      run: npm run lint
    
    - name: Run type checking
      run: npm run type-check
    
    - name: Run unit tests
      run: npm run test:unit
    
    - name: Run integration tests
      run: npm run test:integration
    
    - name: Run performance tests
      run: npm run test:performance
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
    
    - name: Build project
      run: npm run build
```

## ğŸ“ˆ ãƒ†ã‚¹ãƒˆãƒ¡ãƒˆãƒªã‚¯ã‚¹ç›£è¦–

### ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆ

```typescript
// scripts/coverage-report.ts
export class CoverageAnalyzer {
  public static generateReport(): CoverageReport {
    const coverageData = require('../coverage/coverage-final.json');
    
    const summary = {
      totalFiles: Object.keys(coverageData).length,
      averageCoverage: this.calculateAverageCoverage(coverageData),
      uncoveredFiles: this.findUncoveredFiles(coverageData),
      hotspots: this.findComplexityHotspots(coverageData)
    };
    
    return summary;
  }
  
  private static calculateAverageCoverage(data: any): CoverageMetrics {
    let totalLines = 0;
    let coveredLines = 0;
    let totalFunctions = 0;
    let coveredFunctions = 0;
    
    Object.values(data).forEach((file: any) => {
      totalLines += Object.keys(file.s).length;
      coveredLines += Object.values(file.s).filter(hits => hits > 0).length;
      totalFunctions += Object.keys(file.f).length;
      coveredFunctions += Object.values(file.f).filter(hits => hits > 0).length;
    });
    
    return {
      lines: (coveredLines / totalLines) * 100,
      functions: (coveredFunctions / totalFunctions) * 100,
      branches: this.calculateBranchCoverage(data),
      statements: this.calculateStatementCoverage(data)
    };
  }
}
```

### ãƒ†ã‚¹ãƒˆå®Ÿè¡Œçµ±è¨ˆ

```typescript
// src/__tests__/utils/TestMetrics.ts
export class TestMetrics {
  private static testResults: TestResult[] = [];
  
  public static recordTest(name: string, duration: number, status: 'pass' | 'fail'): void {
    this.testResults.push({
      name,
      duration,
      status,
      timestamp: Date.now()
    });
  }
  
  public static generateMetrics(): TestSuiteMetrics {
    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(t => t.status === 'pass').length;
    const averageDuration = this.testResults.reduce((sum, t) => sum + t.duration, 0) / totalTests;
    const slowestTests = this.testResults
      .sort((a, b) => b.duration - a.duration)
      .slice(0, 10);
    
    return {
      totalTests,
      passedTests,
      failedTests: totalTests - passedTests,
      successRate: (passedTests / totalTests) * 100,
      averageDuration,
      totalDuration: this.testResults.reduce((sum, t) => sum + t.duration, 0),
      slowestTests
    };
  }
  
  public static findFlaky Tests(): TestResult[] {
    // å¤±æ•—ç‡ãŒ10-90%ã®ãƒ†ã‚¹ãƒˆã‚’ä¸å®‰å®šã¨åˆ¤å®š
    const testGroups = this.groupTestsByName();
    const flakyTests: TestResult[] = [];
    
    Object.entries(testGroups).forEach(([name, results]) => {
      const failures = results.filter(r => r.status === 'fail').length;
      const failureRate = failures / results.length;
      
      if (failureRate > 0.1 && failureRate < 0.9) {
        flakyTests.push(...results);
      }
    });
    
    return flakyTests;
  }
}
```

## ğŸ“ ç·´ç¿’å•é¡Œ

### ğŸŸ¢ åˆç´šå•é¡Œ
**å•é¡Œ**: VitalsAbility ã‚¯ãƒ©ã‚¹ã® `eatFood()` ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ã€é£Ÿã¹ç‰©ãŒãªã„å ´åˆã€è£…å‚™ã«å¤±æ•—ã—ãŸå ´åˆã®3ã¤ã®ã‚·ãƒŠãƒªã‚ªã‚’ãƒ†ã‚¹ãƒˆã—ã¦ãã ã•ã„ã€‚

<details>
<summary>è§£ç­”ä¾‹</summary>

```typescript
describe('VitalsAbility.eatFood()', () => {
  let mockBot: any;
  let vitalsAbility: VitalsAbility;

  beforeEach(() => {
    mockBot = createMockBot();
    vitalsAbility = new VitalsAbility(mockBot);
  });

  test('should successfully eat food when available', async () => {
    // Arrange
    const breadItem = { name: 'bread', count: 1 };
    mockBot.inventory.findItem = jest.fn().mockReturnValue(breadItem);
    mockBot.equip = jest.fn().mockResolvedValue(undefined);
    mockBot.consume = jest.fn().mockResolvedValue(undefined);

    // Act
    const result = await vitalsAbility.eatFood();

    // Assert
    expect(result).toBe(true);
    expect(mockBot.equip).toHaveBeenCalledWith(breadItem, 'hand');
    expect(mockBot.consume).toHaveBeenCalled();
  });

  test('should return false when no food is available', async () => {
    // Arrange
    mockBot.inventory.findItem = jest.fn().mockReturnValue(null);

    // Act
    const result = await vitalsAbility.eatFood();

    // Assert
    expect(result).toBe(false);
    expect(mockBot.equip).not.toHaveBeenCalled();
    expect(mockBot.consume).not.toHaveBeenCalled();
  });

  test('should handle equipment failure gracefully', async () => {
    // Arrange
    const breadItem = { name: 'bread', count: 1 };
    mockBot.inventory.findItem = jest.fn().mockReturnValue(breadItem);
    mockBot.equip = jest.fn().mockRejectedValue(new Error('Cannot equip'));

    // Act
    const result = await vitalsAbility.eatFood();

    // Assert
    expect(result).toBe(false);
    expect(mockBot.equip).toHaveBeenCalledWith(breadItem, 'hand');
    expect(mockBot.consume).not.toHaveBeenCalled();
  });

  test('should handle consumption failure gracefully', async () => {
    // Arrange
    const breadItem = { name: 'bread', count: 1 };
    mockBot.inventory.findItem = jest.fn().mockReturnValue(breadItem);
    mockBot.equip = jest.fn().mockResolvedValue(undefined);
    mockBot.consume = jest.fn().mockRejectedValue(new Error('Cannot consume'));

    // Act
    const result = await vitalsAbility.eatFood();

    // Assert
    expect(result).toBe(false);
    expect(mockBot.equip).toHaveBeenCalled();
    expect(mockBot.consume).toHaveBeenCalled();
  });
});
```
</details>

### ğŸŸ¡ ä¸­ç´šå•é¡Œ
**å•é¡Œ**: BotScript ã® IFæ–‡ã®å®Ÿè¡Œã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹çµ±åˆãƒ†ã‚¹ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚æ¡ä»¶ãŒçœŸãƒ»å½ã®å ´åˆã€ãƒã‚¹ãƒˆã—ãŸIFæ–‡ã€ELSEåˆ†å²ã‚’å«ã‚€åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚

<details>
<summary>è§£ç­”ä¾‹</summary>

```typescript
describe('BotScript IF Statement Integration Tests', () => {
  let mockBot: any;
  let interpreter: Interpreter;
  let context: ExecutionContext;

  beforeEach(() => {
    mockBot = createMockBot();
    context = new ExecutionContext();
    interpreter = new Interpreter(mockBot, context);
  });

  describe('Simple IF statements', () => {
    test('should execute THEN branch when condition is true', async () => {
      const script = `
        DEF $health = 15
        IF $health > 10 THEN
          SAY "Health is good"
        ENDIF
      `;

      const result = await executeScript(interpreter, script);

      expect(result).toHaveExecutedSuccessfully();
      expect(mockBot.chat).toHaveBeenCalledWith('Health is good');
    });

    test('should skip THEN branch when condition is false', async () => {
      const script = `
        DEF $health = 5
        IF $health > 10 THEN
          SAY "Health is good"
        ENDIF
        SAY "End of script"
      `;

      const result = await executeScript(interpreter, script);

      expect(result).toHaveExecutedSuccessfully();
      expect(mockBot.chat).not.toHaveBeenCalledWith('Health is good');
      expect(mockBot.chat).toHaveBeenCalledWith('End of script');
    });
  });

  describe('IF-ELSE statements', () => {
    test('should execute ELSE branch when condition is false', async () => {
      const script = `
        DEF $health = 5
        IF $health > 10 THEN
          SAY "Health is good"
        ELSE
          SAY "Health is low"
        ENDIF
      `;

      const result = await executeScript(interpreter, script);

      expect(result).toHaveExecutedSuccessfully();
      expect(mockBot.chat).not.toHaveBeenCalledWith('Health is good');
      expect(mockBot.chat).toHaveBeenCalledWith('Health is low');
    });

    test('should execute THEN branch and skip ELSE when condition is true', async () => {
      const script = `
        DEF $health = 15
        IF $health > 10 THEN
          SAY "Health is good"
        ELSE
          SAY "Health is low"
        ENDIF
      `;

      const result = await executeScript(interpreter, script);

      expect(result).toHaveExecutedSuccessfully();
      expect(mockBot.chat).toHaveBeenCalledWith('Health is good');
      expect(mockBot.chat).not.toHaveBeenCalledWith('Health is low');
    });
  });

  describe('Nested IF statements', () => {
    test('should handle nested IF statements correctly', async () => {
      const script = `
        DEF $health = 15
        DEF $food = 8
        IF $health > 10 THEN
          SAY "Health is good"
          IF $food < 10 THEN
            SAY "But food is low"
          ELSE
            SAY "Food is also good"
          ENDIF
        ELSE
          SAY "Health is low"
        ENDIF
      `;

      const result = await executeScript(interpreter, script);

      expect(result).toHaveExecutedSuccessfully();
      expect(mockBot.chat).toHaveBeenCalledWith('Health is good');
      expect(mockBot.chat).toHaveBeenCalledWith('But food is low');
      expect(mockBot.chat).not.toHaveBeenCalledWith('Food is also good');
      expect(mockBot.chat).not.toHaveBeenCalledWith('Health is low');
    });

    test('should handle deeply nested IF statements', async () => {
      const script = `
        DEF $level = 3
        IF $level >= 1 THEN
          SAY "Level 1"
          IF $level >= 2 THEN
            SAY "Level 2"
            IF $level >= 3 THEN
              SAY "Level 3"
            ENDIF
          ENDIF
        ENDIF
      `;

      const result = await executeScript(interpreter, script);

      expect(result).toHaveExecutedSuccessfully();
      expect(mockBot.chat).toHaveBeenCalledWith('Level 1');
      expect(mockBot.chat).toHaveBeenCalledWith('Level 2');
      expect(mockBot.chat).toHaveBeenCalledWith('Level 3');
    });
  });

  describe('Complex conditions', () => {
    test('should handle AND conditions', async () => {
      const script = `
        DEF $health = 15
        DEF $food = 12
        IF $health > 10 AND $food > 10 THEN
          SAY "Both health and food are good"
        ELSE
          SAY "Something is low"
        ENDIF
      `;

      const result = await executeScript(interpreter, script);

      expect(result).toHaveExecutedSuccessfully();
      expect(mockBot.chat).toHaveBeenCalledWith('Both health and food are good');
    });

    test('should handle OR conditions', async () => {
      const script = `
        DEF $health = 5
        DEF $food = 15
        IF $health < 10 OR $food < 10 THEN
          SAY "Something needs attention"
        ELSE
          SAY "Everything is fine"
        ENDIF
      `;

      const result = await executeScript(interpreter, script);

      expect(result).toHaveExecutedSuccessfully();
      expect(mockBot.chat).toHaveBeenCalledWith('Something needs attention');
    });

    test('should handle complex expressions with parentheses', async () => {
      const script = `
        DEF $a = 5
        DEF $b = 10
        DEF $c = 15
        IF ($a + $b) > $c OR $a > $c THEN
          SAY "Complex condition met"
        ELSE
          SAY "Complex condition not met"
        ENDIF
      `;

      const result = await executeScript(interpreter, script);

      expect(result).toHaveExecutedSuccessfully();
      expect(mockBot.chat).toHaveBeenCalledWith('Complex condition not met');
    });
  });

  describe('Variable scope in IF statements', () => {
    test('should handle variable scope correctly', async () => {
      const script = `
        DEF $global_var = "global"
        IF TRUE THEN
          DEF $if_var = "if_scope"
          SAY $global_var
          SAY $if_var
        ENDIF
        SAY $global_var
      `;

      const result = await executeScript(interpreter, script);

      expect(result).toHaveExecutedSuccessfully();
      expect(mockBot.chat).toHaveBeenCalledWith('global');
      expect(mockBot.chat).toHaveBeenCalledWith('if_scope');
    });
  });
});
```
</details>

### ğŸ”´ ä¸Šç´šå•é¡Œ
**å•é¡Œ**: å…¨ã‚·ã‚¹ãƒ†ãƒ ã‚’å¯¾è±¡ã¨ã—ãŸè² è·ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚åŒæ™‚å®Ÿè¡Œã€ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯æ¤œå‡ºã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åŠ£åŒ–ã®ç›£è¦–ã‚’å«ã‚€åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚

<details>
<summary>è§£ç­”ä¾‹</summary>

```typescript
// src/__tests__/performance/LoadTest.framework.ts
export class LoadTestFramework {
  private scenarios: LoadTestScenario[] = [];
  private results: LoadTestResult[] = [];
  private monitoring = new PerformanceMonitor();

  /**
   * è² è·ãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ªã®ç™»éŒ²
   */
  public addScenario(scenario: LoadTestScenario): void {
    this.scenarios.push(scenario);
  }

  /**
   * å…¨ã‚·ãƒŠãƒªã‚ªã®å®Ÿè¡Œ
   */
  public async runAllScenarios(): Promise<LoadTestSummary> {
    console.log(`[LoadTest] Starting ${this.scenarios.length} scenarios...`);
    
    const summary: LoadTestSummary = {
      totalScenarios: this.scenarios.length,
      successfulScenarios: 0,
      failedScenarios: 0,
      totalDuration: 0,
      averageMemoryUsage: 0,
      peakMemoryUsage: 0,
      memoryLeaks: [],
      performanceDegradation: []
    };

    for (const scenario of this.scenarios) {
      try {
        const result = await this.runScenario(scenario);
        this.results.push(result);
        
        if (result.success) {
          summary.successfulScenarios++;
        } else {
          summary.failedScenarios++;
        }
        
        summary.totalDuration += result.duration;
        
      } catch (error) {
        console.error(`[LoadTest] Scenario ${scenario.name} failed: ${error}`);
        summary.failedScenarios++;
      }
    }

    summary.averageMemoryUsage = this.calculateAverageMemoryUsage();
    summary.peakMemoryUsage = this.monitoring.getPeakMemoryUsage();
    summary.memoryLeaks = this.detectMemoryLeaks();
    summary.performanceDegradation = this.detectPerformanceDegradation();

    return summary;
  }

  /**
   * å€‹åˆ¥ã‚·ãƒŠãƒªã‚ªã®å®Ÿè¡Œ
   */
  private async runScenario(scenario: LoadTestScenario): Promise<LoadTestResult> {
    console.log(`[LoadTest] Running scenario: ${scenario.name}`);
    
    const startTime = performance.now();
    const startMemory = this.monitoring.getCurrentMemoryUsage();
    
    try {
      // åŒæ™‚å®Ÿè¡Œã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
      const promises: Promise<any>[] = [];
      
      for (let i = 0; i < scenario.concurrentUsers; i++) {
        promises.push(this.simulateUser(scenario, i));
      }

      // å…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å®Œäº†ã‚’å¾…æ©Ÿ
      await Promise.all(promises);
      
      const endTime = performance.now();
      const endMemory = this.monitoring.getCurrentMemoryUsage();
      
      return {
        scenarioName: scenario.name,
        success: true,
        duration: endTime - startTime,
        memoryUsed: endMemory - startMemory,
        concurrentUsers: scenario.concurrentUsers,
        operationsCompleted: scenario.operationsPerUser * scenario.concurrentUsers,
        averageResponseTime: this.calculateAverageResponseTime(scenario.name),
        throughput: this.calculateThroughput(scenario),
        errors: []
      };
      
    } catch (error) {
      return {
        scenarioName: scenario.name,
        success: false,
        duration: performance.now() - startTime,
        memoryUsed: this.monitoring.getCurrentMemoryUsage() - startMemory,
        concurrentUsers: scenario.concurrentUsers,
        operationsCompleted: 0,
        averageResponseTime: 0,
        throughput: 0,
        errors: [error.message]
      };
    }
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
   */
  private async simulateUser(scenario: LoadTestScenario, userId: number): Promise<void> {
    const mockBot = createMockBot();
    const bot = new Bot(mockBot);
    const interpreter = new Interpreter(bot, new ExecutionContext());
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼å›ºæœ‰ã®é…å»¶ã‚’è¿½åŠ 
    await new Promise(resolve => setTimeout(resolve, userId * scenario.rampUpDelay));

    for (let operation = 0; operation < scenario.operationsPerUser; operation++) {
      const operationStart = performance.now();
      
      try {
        await scenario.operation(bot, interpreter, userId, operation);
        
        const operationEnd = performance.now();
        this.monitoring.recordOperation(scenario.name, operationEnd - operationStart);
        
        // æ“ä½œé–“éš”ã®å¾…æ©Ÿ
        if (scenario.operationInterval > 0) {
          await new Promise(resolve => setTimeout(resolve, scenario.operationInterval));
        }
        
      } catch (error) {
        console.error(`[LoadTest] User ${userId} operation ${operation} failed: ${error}`);
        throw error;
      }
    }
  }

  /**
   * ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã®æ¤œå‡º
   */
  private detectMemoryLeaks(): MemoryLeak[] {
    const leaks: MemoryLeak[] = [];
    const memorySnapshots = this.monitoring.getMemorySnapshots();
    
    // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®ç¶™ç¶šçš„å¢—åŠ ã‚’æ¤œå‡º
    for (let i = 1; i < memorySnapshots.length; i++) {
      const previous = memorySnapshots[i - 1];
      const current = memorySnapshots[i];
      
      const increase = current.heapUsed - previous.heapUsed;
      const increasePercentage = (increase / previous.heapUsed) * 100;
      
      if (increasePercentage > 10) { // 10%ä»¥ä¸Šã®å¢—åŠ 
        leaks.push({
          timestamp: current.timestamp,
          memoryIncrease: increase,
          increasePercentage,
          suspectedCause: this.identifySuspectedCause(current.timestamp)
        });
      }
    }
    
    return leaks;
  }

  /**
   * ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åŠ£åŒ–ã®æ¤œå‡º
   */
  private detectPerformanceDegradation(): PerformanceDegradation[] {
    const degradations: PerformanceDegradation[] = [];
    
    for (const scenario of this.scenarios) {
      const responseTimes = this.monitoring.getResponseTimes(scenario.name);
      
      if (responseTimes.length < 2) continue;
      
      const initial = responseTimes.slice(0, Math.floor(responseTimes.length * 0.1)); // æœ€åˆã®10%
      const final = responseTimes.slice(-Math.floor(responseTimes.length * 0.1)); // æœ€å¾Œã®10%
      
      const initialAvg = initial.reduce((sum, time) => sum + time, 0) / initial.length;
      const finalAvg = final.reduce((sum, time) => sum + time, 0) / final.length;
      
      const degradation = ((finalAvg - initialAvg) / initialAvg) * 100;
      
      if (degradation > 20) { // 20%ä»¥ä¸Šã®åŠ£åŒ–
        degradations.push({
          scenarioName: scenario.name,
          initialAverage: initialAvg,
          finalAverage: finalAvg,
          degradationPercentage: degradation,
          possibleCauses: this.analyzePossibleCauses(scenario.name)
        });
      }
    }
    
    return degradations;
  }
}

/**
 * ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ã‚¯ãƒ©ã‚¹
 */
class PerformanceMonitor {
  private memorySnapshots: MemorySnapshot[] = [];
  private operationTimes = new Map<string, number[]>();
  private gcRunCount = 0;

  constructor() {
    // ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ç›£è¦–
    if (global.gc) {
      const originalGC = global.gc;
      global.gc = () => {
        this.gcRunCount++;
        return originalGC();
      };
    }

    // å®šæœŸçš„ãªãƒ¡ãƒ¢ãƒªã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ
    setInterval(() => {
      this.takeMemorySnapshot();
    }, 1000);
  }

  public takeMemorySnapshot(): void {
    const usage = process.memoryUsage();
    this.memorySnapshots.push({
      timestamp: Date.now(),
      heapUsed: usage.heapUsed,
      heapTotal: usage.heapTotal,
      external: usage.external,
      rss: usage.rss
    });
  }

  public recordOperation(scenarioName: string, responseTime: number): void {
    if (!this.operationTimes.has(scenarioName)) {
      this.operationTimes.set(scenarioName, []);
    }
    this.operationTimes.get(scenarioName)!.push(responseTime);
  }

  public getCurrentMemoryUsage(): number {
    return process.memoryUsage().heapUsed;
  }

  public getPeakMemoryUsage(): number {
    return Math.max(...this.memorySnapshots.map(s => s.heapUsed));
  }

  public getMemorySnapshots(): MemorySnapshot[] {
    return [...this.memorySnapshots];
  }

  public getResponseTimes(scenarioName: string): number[] {
    return [...(this.operationTimes.get(scenarioName) || [])];
  }
}

// è² è·ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œä¾‹
describe('System Load Tests', () => {
  let loadTest: LoadTestFramework;

  beforeEach(() => {
    loadTest = new LoadTestFramework();
  });

  test('concurrent BotScript execution stress test', async () => {
    // åŒæ™‚å®Ÿè¡Œã‚·ãƒŠãƒªã‚ª
    loadTest.addScenario({
      name: 'concurrent_botscript',
      concurrentUsers: 50,
      operationsPerUser: 20,
      rampUpDelay: 10, // 10msé–“éš”ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼è¿½åŠ 
      operationInterval: 100, // 100msé–“éš”ã§æ“ä½œå®Ÿè¡Œ
      operation: async (bot, interpreter, userId, operationId) => {
        const script = `
          DEF $user = ${userId}
          DEF $op = ${operationId}
          SAY "User " + $user + " operation " + $op
          REPEAT 10
            DEF $temp = $loop_index * $user
            IF $temp > 100 THEN
              SAY "Large value: " + $temp
            ENDIF
          ENDREPEAT
        `;
        
        const result = await executeScript(interpreter, script);
        if (result.type !== ExecutionResultType.SUCCESS) {
          throw new Error(`Script execution failed: ${result.message}`);
        }
      }
    });

    // ãƒ¡ãƒ¢ãƒªé›†ç´„çš„ã‚·ãƒŠãƒªã‚ª
    loadTest.addScenario({
      name: 'memory_intensive',
      concurrentUsers: 10,
      operationsPerUser: 100,
      rampUpDelay: 50,
      operationInterval: 50,
      operation: async (bot, interpreter, userId, operationId) => {
        const context = new ExecutionContext();
        
        // å¤§é‡ã®å¤‰æ•°ã‚’ä½œæˆ
        for (let i = 0; i < 1000; i++) {
          context.setVariable(`$var${i}`, `value${i}_${userId}_${operationId}`);
        }
        
        // è¤‡é›‘ãªè¨ˆç®—
        for (let i = 0; i < 100; i++) {
          const value = context.getVariable(`$var${i}`);
          context.setVariable(`$calculated${i}`, value + '_processed');
        }
        
        context.cleanup();
      }
    });

    const summary = await loadTest.runAllScenarios();

    // çµæœã®æ¤œè¨¼
    expect(summary.successfulScenarios).toBe(summary.totalScenarios);
    expect(summary.memoryLeaks).toHaveLength(0);
    expect(summary.performanceDegradation).toHaveLength(0);
    expect(summary.peakMemoryUsage).toBeLessThan(500 * 1024 * 1024); // 500MBæœªæº€
  }, 60000); // 60ç§’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
});

// å‹å®šç¾©
interface LoadTestScenario {
  name: string;
  concurrentUsers: number;
  operationsPerUser: number;
  rampUpDelay: number;
  operationInterval: number;
  operation: (bot: Bot, interpreter: Interpreter, userId: number, operationId: number) => Promise<void>;
}

interface LoadTestResult {
  scenarioName: string;
  success: boolean;
  duration: number;
  memoryUsed: number;
  concurrentUsers: number;
  operationsCompleted: number;
  averageResponseTime: number;
  throughput: number;
  errors: string[];
}

interface LoadTestSummary {
  totalScenarios: number;
  successfulScenarios: number;
  failedScenarios: number;
  totalDuration: number;
  averageMemoryUsage: number;
  peakMemoryUsage: number;
  memoryLeaks: MemoryLeak[];
  performanceDegradation: PerformanceDegradation[];
}

interface MemoryLeak {
  timestamp: number;
  memoryIncrease: number;
  increasePercentage: number;
  suspectedCause: string;
}

interface PerformanceDegradation {
  scenarioName: string;
  initialAverage: number;
  finalAverage: number;
  degradationPercentage: number;
  possibleCauses: string[];
}

interface MemorySnapshot {
  timestamp: number;
  heapUsed: number;
  heapTotal: number;
  external: number;
  rss: number;
}
```
</details>

## ğŸ† è‡ªå·±è©•ä¾¡ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

- [ ] **åˆç´š**: åŸºæœ¬çš„ãªå˜ä½“ãƒ†ã‚¹ãƒˆã®ä½œæˆã¨ãƒ¢ãƒƒã‚¯ã®ä½¿ç”¨æ–¹æ³•ã‚’ç†è§£ã—ã¦ã„ã‚‹
- [ ] **ä¸­ç´š**: çµ±åˆãƒ†ã‚¹ãƒˆã¨ãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ªã®è¨­è¨ˆãŒã§ãã‚‹
- [ ] **ä¸Šç´š**: è² è·ãƒ†ã‚¹ãƒˆã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã§ãã‚‹

## ğŸ“š æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

ãƒ†ã‚¹ãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’ç†è§£ã—ãŸã‚‰ã€å®Ÿéš›ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ï¼š
1. **ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã®å‘ä¸Š** - æœªãƒ†ã‚¹ãƒˆéƒ¨åˆ†ã®ç‰¹å®šã¨è¿½åŠ ãƒ†ã‚¹ãƒˆä½œæˆ
2. **CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®æœ€é©åŒ–** - ãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ™‚é–“ã®çŸ­ç¸®ã¨ä¸¦åˆ—åŒ–
3. **ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã®å¼·åŒ–** - æœ¬ç•ªç’°å¢ƒã§ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–å®Ÿè£…

ã“ã‚Œã§ã€å…¨ã¦ã®è§£èª¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒå®Œæˆã—ã¾ã—ãŸã€‚åŒ…æ‹¬çš„ãªæŠ€è¡“è³‡æ–™ã¨ã—ã¦ã€è‡ªä½œè¨€èªé–‹ç™ºã‹ã‚‰ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã¾ã§ã€ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ãƒ¬ãƒ™ãƒ«ã®çŸ¥è­˜ã‚’ç¿’å¾—ã—ã¦ã„ãŸã ã‘ã¾ã™ã€‚