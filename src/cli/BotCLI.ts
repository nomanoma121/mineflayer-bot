#!/usr/bin/env node

import { Command } from 'commander';
import fs from 'fs';
import path from 'path';
import { ConfigManager } from '../config/ConfigManager';
import { spawn, ChildProcess } from 'child_process';

/**
 * Minecraft Bot CLI „ÉÑ„Éº„É´
 * „Éú„ÉÉ„Éà„ÅÆË®≠ÂÆöÁÆ°ÁêÜ„ÄÅËµ∑Âãï„ÄÅÁõ£Ë¶ñ„ÇíË°å„ÅÜ„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ
 */
export class BotCLI {
  private program: Command;
  private configManager: ConfigManager;
  private runningProcess: ChildProcess | null = null;

  constructor() {
    this.program = new Command();
    this.configManager = new ConfigManager();
    this.setupCommands();
  }

  /**
   * CLI„Ç≥„Éû„É≥„Éâ„ÅÆË®≠ÂÆö
   */
  private setupCommands(): void {
    this.program
      .name('minecraft-bot')
      .description('Minecraft Bot management CLI')
      .version('2.0.0');

    // Ë®≠ÂÆöÈñ¢ÈÄ£„Ç≥„Éû„É≥„Éâ
    this.setupConfigCommands();
    
    // „Éú„ÉÉ„ÉàÂà∂Âæ°„Ç≥„Éû„É≥„Éâ
    this.setupBotCommands();
    
    // ÈñãÁô∫ÊîØÊè¥„Ç≥„Éû„É≥„Éâ
    this.setupDevCommands();
  }

  /**
   * Ë®≠ÂÆöÈñ¢ÈÄ£„Ç≥„Éû„É≥„Éâ„ÅÆË®≠ÂÆö
   */
  private setupConfigCommands(): void {
    const configCmd = this.program
      .command('config')
      .description('Configuration management commands');

    configCmd
      .command('show')
      .description('Show current configuration')
      .option('-s, --summary', 'Show configuration summary')
      .option('-e, --env', 'Show as environment variables')
      .action((options) => {
        if (options.summary) {
          console.log(this.configManager.getConfigSummary());
        } else if (options.env) {
          console.log(this.configManager.exportToEnv());
        } else {
          console.log(JSON.stringify(this.configManager.getConfig(), null, 2));
        }
      });

    configCmd
      .command('validate')
      .description('Validate configuration')
      .action(() => {
        const validation = this.configManager.validateConfig();
        if (validation.isValid) {
          console.log('‚úì Configuration is valid');
        } else {
          console.log('‚úó Configuration has errors:');
          validation.errors.forEach(error => console.log(`  - ${error}`));
          process.exit(1);
        }
      });

    configCmd
      .command('create')
      .description('Create default configuration file')
      .option('-f, --force', 'Overwrite existing configuration')
      .action((options) => {
        const configPath = path.join(process.cwd(), 'bot.config.json');
        
        if (fs.existsSync(configPath) && !options.force) {
          console.log('Configuration file already exists. Use --force to overwrite.');
          process.exit(1);
        }
        
        this.configManager.createDefaultConfig();
      });

    configCmd
      .command('set <key> <value>')
      .description('Set configuration value')
      .action((key: string, value: string) => {
        try {
          // „Éë„Éº„Çπ„Åó„Å¶„Çø„Ç§„Éó„ÇíÊé®ÂÆö
          let parsedValue: any = value;
          if (value === 'true') parsedValue = true;
          else if (value === 'false') parsedValue = false;
          else if (!isNaN(Number(value))) parsedValue = Number(value);
          else if (value.includes(',')) parsedValue = value.split(',');

          // „Éç„Çπ„Éà„Åï„Çå„Åü„Ç≠„Éº„ÅÆÊõ¥Êñ∞
          const keys = key.split('.');
          const update: any = {};
          let current = update;
          
          for (let i = 0; i < keys.length - 1; i++) {
            current[keys[i]] = {};
            current = current[keys[i]];
          }
          current[keys[keys.length - 1]] = parsedValue;

          this.configManager.updateConfig(update);
          this.configManager.saveConfig();
          
          console.log(`‚úì Updated ${key} = ${value}`);
        } catch (error) {
          console.error(`Failed to update configuration: ${error}`);
          process.exit(1);
        }
      });

    configCmd
      .command('get <key>')
      .description('Get configuration value')
      .action((key: string) => {
        const value = this.configManager.getValue(key);
        if (value !== undefined) {
          console.log(JSON.stringify(value, null, 2));
        } else {
          console.log(`Configuration key '${key}' not found`);
          process.exit(1);
        }
      });
  }

  /**
   * „Éú„ÉÉ„ÉàÂà∂Âæ°„Ç≥„Éû„É≥„Éâ„ÅÆË®≠ÂÆö
   */
  private setupBotCommands(): void {
    this.program
      .command('start')
      .description('Start the Minecraft bot')
      .option('-d, --daemon', 'Run as daemon process')
      .option('-w, --watch', 'Watch for file changes and restart')
      .option('-c, --config <path>', 'Use custom config file')
      .action((options) => {
        if (options.config) {
          this.configManager = new ConfigManager(options.config);
        }

        const validation = this.configManager.validateConfig();
        if (!validation.isValid) {
          console.log('‚úó Configuration validation failed:');
          validation.errors.forEach(error => console.log(`  - ${error}`));
          process.exit(1);
        }

        console.log('ü§ñ Starting Minecraft Bot...');
        console.log(this.configManager.getConfigSummary());
        
        if (options.watch) {
          this.startWithWatch();
        } else if (options.daemon) {
          this.startAsDaemon();
        } else {
          this.startBot();
        }
      });

    this.program
      .command('stop')
      .description('Stop the running bot')
      .action(() => {
        if (this.runningProcess) {
          console.log('üõë Stopping bot...');
          this.runningProcess.kill('SIGTERM');
          this.runningProcess = null;
        } else {
          console.log('No bot process is currently running');
        }
      });

    this.program
      .command('restart')
      .description('Restart the bot')
      .option('-c, --config <path>', 'Use custom config file')
      .action((options) => {
        console.log('üîÑ Restarting bot...');
        if (this.runningProcess) {
          this.runningProcess.kill('SIGTERM');
          this.runningProcess = null;
        }
        
        setTimeout(() => {
          if (options.config) {
            this.configManager = new ConfigManager(options.config);
          }
          this.startBot();
        }, 1000);
      });

    this.program
      .command('status')
      .description('Show bot status')
      .action(() => {
        if (this.runningProcess) {
          console.log('üü¢ Bot is running');
          console.log(`Process ID: ${this.runningProcess.pid}`);
        } else {
          console.log('üî¥ Bot is not running');
        }
        
        console.log('\nConfiguration:');
        console.log(this.configManager.getConfigSummary());
      });
  }

  /**
   * ÈñãÁô∫ÊîØÊè¥„Ç≥„Éû„É≥„Éâ„ÅÆË®≠ÂÆö
   */
  private setupDevCommands(): void {
    const devCmd = this.program
      .command('dev')
      .description('Development utilities');

    devCmd
      .command('test')
      .description('Run tests')
      .option('-w, --watch', 'Watch mode')
      .option('-c, --coverage', 'Generate coverage report')
      .action((options) => {
        const args = ['test'];
        if (options.watch) args.push('--watch');
        if (options.coverage) args.push('--coverage');
        
        const testProcess = spawn('npm', ['run', ...args], {
          stdio: 'inherit',
          shell: true
        });
        
        testProcess.on('close', (code) => {
          process.exit(code || 0);
        });
      });

    devCmd
      .command('build')
      .description('Build the project')
      .option('-w, --watch', 'Watch mode')
      .action((options) => {
        const args = options.watch ? ['run', 'build', '--watch'] : ['run', 'build'];
        
        const buildProcess = spawn('npm', args, {
          stdio: 'inherit',
          shell: true
        });
        
        buildProcess.on('close', (code) => {
          process.exit(code || 0);
        });
      });

    devCmd
      .command('lint')
      .description('Run linter')
      .option('--fix', 'Auto-fix issues')
      .action((options) => {
        const args = ['run', 'lint'];
        if (options.fix) args.push('--', '--fix');
        
        const lintProcess = spawn('npm', args, {
          stdio: 'inherit',
          shell: true
        });
        
        lintProcess.on('close', (code) => {
          process.exit(code || 0);
        });
      });

    devCmd
      .command('generate-docs')
      .description('Generate documentation')
      .action(() => {
        console.log('üìñ Generating documentation...');
        // TODO: Implement documentation generation
        console.log('Documentation generation not yet implemented');
      });
  }

  /**
   * ÈÄöÂ∏∏„É¢„Éº„Éâ„Åß„Éú„ÉÉ„Éà„ÇíÈñãÂßã
   */
  private startBot(): void {
    try {
      this.runningProcess = spawn('npm', ['run', 'start'], {
        stdio: 'inherit',
        shell: true,
        env: {
          ...process.env,
          ...this.envFromConfig()
        }
      });

      this.runningProcess.on('close', (code) => {
        console.log(`Bot process exited with code ${code}`);
        this.runningProcess = null;
        
        if (code !== 0) {
          const config = this.configManager.getConfig();
          if (config.bot.maxRetries > 0) {
            console.log(`Retrying in ${config.bot.retryDelay}ms...`);
            setTimeout(() => this.startBot(), config.bot.retryDelay);
          }
        }
      });

      this.runningProcess.on('error', (error) => {
        console.error('Failed to start bot process:', error);
      });

    } catch (error) {
      console.error('Failed to start bot:', error);
      process.exit(1);
    }
  }

  /**
   * „Éá„Éº„É¢„É≥„É¢„Éº„Éâ„Åß„Éú„ÉÉ„Éà„ÇíÈñãÂßã
   */
  private startAsDaemon(): void {
    const logFile = path.join(process.cwd(), 'bot.log');
    const pidFile = path.join(process.cwd(), 'bot.pid');

    console.log(`Starting bot as daemon, logs: ${logFile}`);
    
    this.runningProcess = spawn('npm', ['run', 'start'], {
      detached: true,
      stdio: ['ignore', fs.openSync(logFile, 'a'), fs.openSync(logFile, 'a')],
      shell: true,
      env: {
        ...process.env,
        ...this.envFromConfig()
      }
    });

    fs.writeFileSync(pidFile, String(this.runningProcess.pid));
    this.runningProcess.unref();
    
    console.log(`Bot started as daemon with PID: ${this.runningProcess.pid}`);
    process.exit(0);
  }

  /**
   * „Éï„Ç°„Ç§„É´Áõ£Ë¶ñ„É¢„Éº„Éâ„Åß„Éú„ÉÉ„Éà„ÇíÈñãÂßã
   */
  private startWithWatch(): void {
    console.log('üîÑ Starting bot in watch mode...');
    
    // „Éï„Ç°„Ç§„É´Áõ£Ë¶ñ„ÅÆÂÆüË£Ö
    const chokidar = require('chokidar');
    const watcher = chokidar.watch(['src/**/*.ts', 'bot.config.json'], {
      ignored: /node_modules/,
      persistent: true
    });

    let restartTimeout: NodeJS.Timeout | null = null;

    watcher.on('change', (path: string) => {
      console.log(`üìÅ File changed: ${path}`);
      
      if (restartTimeout) {
        clearTimeout(restartTimeout);
      }
      
      restartTimeout = setTimeout(() => {
        if (this.runningProcess) {
          console.log('üîÑ Restarting bot due to file changes...');
          this.runningProcess.kill('SIGTERM');
        }
        
        setTimeout(() => {
          this.configManager.reloadConfig();
          this.startBot();
        }, 1000);
      }, 1000);
    });

    this.startBot();
  }

  /**
   * Ë®≠ÂÆö„Åã„ÇâÁí∞Â¢ÉÂ§âÊï∞„ÇíÁîüÊàê
   */
  private envFromConfig(): Record<string, string> {
    const config = this.configManager.getConfig();
    return {
      MC_HOST: config.server.host,
      MC_PORT: String(config.server.port),
      MC_VERSION: config.server.version,
      MC_USERNAME: config.bot.username,
      MC_AUTH: config.bot.auth,
      MC_AUTO_EAT: String(config.features.autoEat),
      MC_AUTO_RESPAWN: String(config.features.autoRespawn),
      MC_LOG_LEVEL: config.features.logLevel,
    };
  }

  /**
   * CLI„ÇíÂÆüË°å
   */
  public run(argv?: string[]): void {
    // „Éó„É≠„Çª„ÇπÁµÇ‰∫ÜÊôÇ„ÅÆÂá¶ÁêÜ
    process.on('SIGINT', () => {
      console.log('\nüõë Received SIGINT, shutting down...');
      if (this.runningProcess) {
        this.runningProcess.kill('SIGTERM');
      }
      process.exit(0);
    });

    process.on('SIGTERM', () => {
      console.log('\nüõë Received SIGTERM, shutting down...');
      if (this.runningProcess) {
        this.runningProcess.kill('SIGTERM');
      }
      process.exit(0);
    });

    this.program.parse(argv);
  }
}

// CLIÂÆüË°å„ÅÆ„Ç®„É≥„Éà„É™„Éº„Éù„Ç§„É≥„Éà
if (require.main === module) {
  const cli = new BotCLI();
  cli.run();
}